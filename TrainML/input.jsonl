{"messages": [{"role": "system", "content": "You are an AI that writes secure Solidity smart contracts for trading."}, {"role": "user", "content": "Write a Solidity smart contract that swaps ERC-20 tokens atomically between two users."}, {"role": "assistant", "content": "pragma solidity ^0.8.0;\n\ninterface IERC20 {...}\ncontract TokenSwap {...}"}]}
{"messages": [{"role": "system", "content": "You generate Solidity smart contracts that ensure safe token transfers."}, {"role": "user", "content": "How do I ensure a token swap only happens if both parties have approved allowances?"}, {"role": "assistant", "content": "You must check token allowances before swapping:\n\nrequire(token1.allowance(owner1, address(this)) >= _amount1, 'Token 1 allowance too low');\nrequire(token2.allowance(owner2, address(this)) >= _amount2, 'Token 2 allowance too low');"}]}
{"messages": [{"role": "system", "content": "You generate Solidity smart contracts that ensure secure token swaps."}, {"role": "user", "content": "How do I safely transfer tokens in a swap contract?"}, {"role": "assistant", "content": "Use a private function to safely call transferFrom and check for success:\n\nfunction _safeTransferFrom(IERC20 token, address sender, address recipient, uint256 amount) private {\n  bool sent = token.transferFrom(sender, recipient, amount);\n  require(sent, 'Token transfer failed');\n}"}]}
{"messages": [{"role": "system", "content": "You generate Solidity smart contracts that allow time-locked token swaps."}, {"role": "user", "content": "Modify a token swap contract so that the swap can only happen after a certain timestamp."}, {"role": "assistant", "content": "uint256 public unlockTime;\n\nconstructor(uint256 _unlockTime) {\n  unlockTime = _unlockTime;\n}\n\nrequire(block.timestamp >= unlockTime, 'Swap is time-locked');"}]}
{"messages": [{"role": "system", "content": "You write Solidity smart contracts that protect against slippage in swaps."}, {"role": "user", "content": "Modify a token swap contract to include slippage protection."}, {"role": "assistant", "content": "function swap(uint256 _amount1, uint256 _amount2, uint256 minAmount1, uint256 minAmount2) public {\n  require(_amount1 >= minAmount1, 'Slippage too high for Token 1');\n  require(_amount2 >= minAmount2, 'Slippage too high for Token 2');\n}"}]}
{"messages": [{"role": "system", "content": "You are an AI that writes Solidity smart contracts for Uniswap integrations."}, {"role": "user", "content": "Write a Solidity smart contract that swaps WETH for DAI using Uniswap V3."}, {"role": "assistant", "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.8.9;\npragma abicoder v2;\n\nimport \"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\";\nimport \"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\";\n\ncontract SimpleSwap {\n    ISwapRouter public immutable swapRouter;\n    address public constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address public constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    uint24 public constant feeTier = 3000;\n\n    constructor(ISwapRouter _swapRouter) {\n        swapRouter = _swapRouter;\n    }\n\n    function swapWETHForDAI(uint256 amountIn) external returns (uint256 amountOut) {\n        // Transfer the specified amount of WETH9 to this contract.\n        TransferHelper.safeTransferFrom(WETH9, msg.sender, address(this), amountIn);\n        // Approve the router to spend WETH9.\n        TransferHelper.safeApprove(WETH9, address(swapRouter), amountIn);\n        // Create the params that will be used to execute the swap\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({\n            tokenIn: WETH9,\n            tokenOut: DAI,\n            fee: feeTier,\n            recipient: msg.sender,\n            deadline: block.timestamp,\n            amountIn: amountIn,\n            amountOutMinimum: 0,\n            sqrtPriceLimitX96: 0\n        });\n        // The call to exactInputSingle executes the swap.\n        amountOut = swapRouter.exactInputSingle(params);\n        return amountOut;\n    }\n}"}]}
{"messages": [{"role": "system", "content": "You are an AI that writes Solidity smart contracts for Ethereum wallets."}, {"role": "user", "content": "Write a Solidity smart contract for a basic Ethereum wallet where only the owner can withdraw funds."}, {"role": "assistant", "content": "// SPDX-License-Identifier: MIT\n\n/*\nhttps://solidity-by-example.org/app/ether-wallet\n\nAn example of a basic wallet.\n\n  Anyone can send ETH.\n  Only the owner can withdraw.\n*/\n\npragma solidity ^0.8.9;\n\ncontract EtherWallet {\n    address payable public owner;\n\n    constructor() payable {\n        owner = payable(msg.sender);\n    }\n\n    function withdraw(uint256 amount) external {\n        require(msg.sender == owner, \"caller is not owner\");\n        payable(owner).transfer(amount);\n    }\n\n    function getBalance() external view returns (uint256) {\n        return address(this).balance;\n    }\n}"}]}
{"messages": [{"role": "system", "content": "You are an AI that writes Solidity smart contracts for ERC-20 tokens."}, {"role": "user", "content": "Write a Solidity smart contract for an ERC-20 token with standard functions like transfer, approve, and allowance."}, {"role": "assistant", "content": "// SPDX-License-Identifier: MIT\n//\n// https://cryptomarketpool.com/erc20-token-solidity-smart-contract/\n\npragma solidity ^0.8.0;\n\ninterface ERC20 {\n    function totalSupply() external pure returns (uint256 _totalSupply);\n\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    function transfer(address _to, uint256 _value) external returns (bool success);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool success);\n\n    function approve(address _spender, uint256 _value) external returns (bool success);\n\n    function allowance(address _owner, address _sender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract MyERC20Token is ERC20 {\n    string public constant symbol = \"MET\";\n    string public constant name = \"My ERC20 Token\";\n    uint8 public constant decimals = 18;\n\n    // 1,000,000 + 18 zeros\n    uint256 private constant __totalSupply = 1000000000000000000000000;\n\n    // this mapping is where we store the balances of an address\n    mapping(address => uint256) private __balanceOf;\n\n    // This is for the approval function to determine how much an address can spend\n    mapping(address => mapping(address => uint256)) private __allowances;\n\n    constructor() {\n        __balanceOf[msg.sender] = __totalSupply; //the creator of the contract has the total supply and no one can create tokens\n    }\n\n    function totalSupply() public pure override returns (uint256) {\n        return __totalSupply;\n    }\n\n    function balanceOf(address _address) public view override returns (uint256) {\n        return __balanceOf[_address];\n    }\n\n    function transfer(address _to, uint256 _value) public override returns (bool) {\n        if (_value > 0 && _value <= balanceOf(msg.sender)) {\n            __balanceOf[msg.sender] -= _value;\n            __balanceOf[_to] += _value;\n            emit Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) public override returns (bool) {\n        if (\n            _value > 0 &&\n            __allowances[_from][msg.sender] > 0 &&\n            __allowances[_from][msg.sender] >= _value &&\n            !isContract(_to)\n        ) {\n            __balanceOf[_from] -= _value;\n            __balanceOf[_to] += _value;\n            emit Transfer(_from, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function isContract(address _address) public view returns (bool) {\n        uint256 codeSize;\n        assembly {\n            codeSize := extcodesize(_address)\n        }\n        return codeSize > 0;\n    }\n\n    function approve(address _spender, uint256 _value) external override returns (bool) {\n        __allowances[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining) {\n        return __allowances[_owner][_spender];\n    }\n}"}]} 
{"messages": [{"role": "system", "content": "You are an AI that writes Solidity smart contracts for shared wallets."}, {"role": "user", "content": "Write a Solidity smart contract for a shared wallet where multiple owners can withdraw and transfer funds."}, {"role": "assistant", "content": "// SPDX-License-Identifier: MIT\n//\n// https://cryptomarketpool.com/shared-wallet-solidity-smart-contract/\n\npragma solidity ^0.8.0;\n\ncontract SharedWallet {\n    address private _owner;\n\n    // list of shared owners. bool is used to determine if the address is enabled or disabled\n    mapping(address => bool) private _owners;\n\n    // required owner of the contract\n    modifier isOwner() {\n        require(msg.sender == _owner, \"Not contract owner\");\n        _;\n    }\n\n    // required to be valid either contract owner or enabled owner of shared wallet\n    modifier validOwner() {\n        require(msg.sender == _owner || _owners[msg.sender], \"Not contract owner or owners of shared wallet\");\n        _;\n    }\n\n    event DepositFunds(address from, uint256 amount);\n    event WithdrawFunds(address from, uint256 amount);\n    event TransferFunds(address from, address to, uint256 amount);\n\n    constructor() {\n        _owner = msg.sender;\n    }\n\n    // add an owner of shared wallet\n    function addOwner(address owner) public isOwner {\n        _owners[owner] = true;\n    }\n\n    // remove an owner of shared wallet\n    function removeOwner(address owner) public isOwner {\n        _owners[owner] = false;\n    }\n\n    // receive the deposit into shared wallet (contract's balance)\n    receive() external payable {\n        emit DepositFunds(msg.sender, msg.value);\n    }\n\n    // withdraw fund from the shared wallet into the signer of transaction\n    function withdraw(uint256 amount) public validOwner {\n        require(address(this).balance >= amount);\n        payable(msg.sender).transfer(amount);\n        emit WithdrawFunds(msg.sender, amount);\n    }\n\n    // transfer fund from the shared wallet into another address\n    function transferTo(address payable to, uint256 amount) public validOwner {\n        require(address(this).balance >= amount);\n        payable(to).transfer(amount);\n        emit TransferFunds(msg.sender, to, amount);\n    }\n}"}]}
{"messages": [{"role": "system", "content": "You are an AI that writes Solidity smart contracts for flash loans."}, {"role": "user", "content": "Write a Solidity smart contract for a flash borrower that interacts with an ERC-3156 flash lender."}, {"role": "assistant", "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./interfaces/IERC3156FlashBorrower.sol\";\nimport \"./interfaces/IERC3156FlashLender.sol\";\n\ncontract FlashBorrower is IERC3156FlashBorrower {\n    enum Action {\n        NORMAL,\n        OTHER\n    }\n\n    IERC3156FlashLender lender;\n\n    constructor(IERC3156FlashLender lender_) {\n        lender = lender_;\n    }\n\n    /// @dev ERC-3156 Flash loan callback\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external override returns (bytes32) {\n        require(msg.sender == address(lender), \"FlashBorrower: Untrusted lender\");\n        require(initiator == address(this), \"FlashBorrower: Untrusted loan initiator\");\n\n        // silence warning about unused variable without the addition of bytecode.\n        token;\n        amount;\n        fee;\n\n        // Your logic goes here. Do whatever you want with the tokens\n        //...\n        Action action = abi.decode(data, (Action));\n        if (action == Action.NORMAL) {\n            // do one thing\n        } else if (action == Action.OTHER) {\n            // do another\n        }\n\n        return keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n    }\n\n    /// @dev Initiate a flash loan\n    function flashBorrow(address token, uint256 amount) public {\n        bytes memory data = abi.encode(Action.NORMAL);\n        uint256 _allowance = IERC20(token).allowance(address(this), address(lender));\n        uint256 _fee = lender.flashFee(token, amount);\n        uint256 _repayment = amount + _fee;\n        IERC20(token).approve(address(lender), _allowance + _repayment);\n        lender.flashLoan(this, token, amount, data);\n    }\n}"}]}
{"messages": [{"role": "system", "content": "You are an AI that writes Solidity smart contracts for flash loan lenders."}, {"role": "user", "content": "Write a Solidity smart contract for a flash lender that supports ERC-3156 flash loans."}, {"role": "assistant", "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./interfaces/IERC3156FlashBorrower.sol\";\nimport \"./interfaces/IERC3156FlashLender.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows flash lending.\n */\ncontract FlashLender is IERC3156FlashLender {\n    bytes32 public constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    mapping(address => bool) public supportedTokens;\n    uint256 public fee; //  1 == 0.01 %\n\n    /**\n     * @param supportedTokens_ Token contracts supported for flash lending.\n     * @param fee_ The percentage of the loan `amount` that needs to be repaid, in addition to `amount`.\n     */\n    constructor(address[] memory supportedTokens_, uint256 fee_) {\n        for (uint256 i = 0; i < supportedTokens_.length; i++) {\n            supportedTokens[supportedTokens_[i]] = true;\n        }\n        fee = fee_;\n    }\n\n    /**\n     * @dev Loan `amount` tokens to `receiver`, and takes it back plus a `flashFee` after the callback.\n     * @param receiver The contract receiving the tokens, needs to implement the `onFlashLoan(address user, uint256 amount, uint256 fee, bytes calldata)` interface.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param data A data parameter to be passed on to the `receiver` for any custom use.\n     */\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external override returns (bool) {\n        require(supportedTokens[token], \"FlashLender: Unsupported currency\");\n\n        uint256 _fee = _flashFee(token, amount);\n        require(IERC20(token).transfer(address(receiver), amount), \"FlashLender: Transfer failed\");\n\n        require(\n            receiver.onFlashLoan(msg.sender, token, amount, _fee, data) == CALLBACK_SUCCESS,\n            \"FlashLender: Callback failed\"\n        );\n        require(\n            IERC20(token).transferFrom(address(receiver), address(this), amount + _fee),\n            \"FlashLender: Repay failed\"\n        );\n\n        return true;\n    }\n\n    /**\n     * @dev The amount of currency available to be lent.\n     * @param token The loan currency.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashFloan(address token) external view override returns (uint256) {\n        return supportedTokens[token] ? IERC20(token).balanceOf(address(this)) : 0;\n    }\n\n    /**\n     * @dev The fee to be charged for a given loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(address token, uint256 amount) external view override returns (uint256) {\n        require(supportedTokens[token], \"FlashLender: Unsupported currency\");\n\n        return _flashFee(token, amount);\n    }\n\n    /**\n     * @dev The fee to be charged for a given loan. Internal function with no checks.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function _flashFee(address token, uint256 amount) internal view returns (uint256) {\n        // silence warning about unused variable without the addition of bytecode.\n        token;\n\n        return (amount * fee) / 10000;\n    }\n}"}]}
